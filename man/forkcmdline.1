.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FORKCMDLINE 1"
.TH FORKCMDLINE 1 "2018-11-29" "perl v5.28.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
forkcmdline \- run Perl "system" function with "Parallel::ForkManager"
from input or file.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    forkcmdline [OPTIONS] CMDLINE [CMDLINE ...]
\&    forkcmdline [OPTIONS] \-\-read CMDFILE [CMDFILE ...]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Dependencies"
.IX Subsection "Dependencies"
Perl standard modules: \f(CW\*(C`strict\*(C'\fR, \f(CW\*(C`warnings\*(C'\fR (with \f(CW\*(C`FATAL\*(C'\fR warnings).
.PP
\&\f(CW\*(C`Parallel::ForkManager\*(C'\fR \- for Perl fork managing.
.PP
\&\f(CW\*(C`Time::HiRes\*(C'\fR \- for precise elapsed time.
.PP
\&\f(CW\*(C`Getopt::Long\*(C'\fR \- for handling command line options.
.SS "Options"
.IX Subsection "Options"
.Vb 10
\&    \-a, \-\-writeall=FILEBASE 
\&                write exitcodes, stdout and stderr of cmdlines to files with fixed base name (or path) 
\&                and added fork number suffix: .exit.1 and .stdout.1 and .stderr.1 and so on
\&                default: do not write
\&                warning: redefines other write options
\&    \-c, \-\-checkexit=INTEGER[,INTEGER[,...]]
\&                check if every command ended with any exitcode from list, 
\&                generate error if not, default: do not check
\&    \-e, \-\-writestderr=FILEBASE   
\&                write stderr of cmdlines to files with fixed base name (or path) 
\&                and added fork number suffix: .stderr.1 and so on
\&                default: do not write
\&    \-f, \-\-forks=INTEGER     
\&            number of forks to run in parallel, 
\&            possible values:
\&                1 \- count number automatically (default)
\&                0 \- do not fork and run consistently (for debug)
\&                2 and so on \- fixed number of forks
\&    \-h, \-\-help              
\&            show minimal help end exit
\&    \-o, \-\-writestdout=FILEBASE   
\&                write stdout of cmdlines to files with fixed base name (or path) 
\&                and added fork number suffix: .stdout.1 and so on
\&                default: do not write
\&    \-q, \-\-quiet             
\&            do not chat while working (no prints or warnings)
\&    \-r, \-\-read
\&                read and run command lines from files, 
\&                one line = one command,
\&                empty and space only lines are ignored
\&    \-s, \-\-sleep=FLOAT       
\&                sleep time in seconds of pseudo\-blocking calls, default: 0.01
\&    \-x, \-\-writeexit=FILEBASE   
\&                write exitcodes of cmdlines to files with fixed base name (or path) 
\&                and added fork number suffix: .exit.1 and so on
\&                default: do not write
.Ve
.SS "Getting fork number"
.IX Subsection "Getting fork number"
If the number of forks is not set by option, it is retrieved from:
.PP
1) environmental variable \f(CW\*(C`NUMBER_OF_PROCESSORS\*(C'\fR, targeting Windows-like OSes;
.PP
2) \f(CW\*(C`nproc\*(C'\fR utility, targeting Unix-like OSes.
.PP
If above steps fail, it is simply set to 4.
.PP
Finally, it is multiplied by 2 targeting 2 forks per core 
(this assumption made by script author after some modest tests).
.PP
The number of forks is reduced to the number of cmdlines if later is smaller.
.PP
It is set to zero, if there is only one cmdline to run.
.PP
All forks are waited to end. If fork is lost, warning is generated, 
though usually it does not mean that process has failed. 
So additional analysis should be made by script caller, 
e.g..: check result file of \f(CW\*(C`cmdline\*(C'\fR, check existence of \f(CW\*(C`writeexit\*(C'\fR files and so on.
.PP
If \f(CW\*(C`\-\-quiet\*(C'\fR is not used, end time is printed to \s-1STDOUT.\s0
.SH "TODO"
.IX Header "TODO"
\&\- Tests on Windows.
.PP
\&\- Are there any reasons to hard-code checking existence of \f(CW\*(C`writeexit\*(C'\fR and so on files?
.PP
\&\- Reproduce situations when \f(CW$exitcode\fR in \f(CW\*(C`run_on_finish\*(C'\fR
is less reliable than from \f(CW$datastructref\fR.
.PP
\&\- Are there any reasons not to check core dump from \f(CW\*(C`run_on_finish\*(C'\fR?
.PP
\&\- Reproduce and test situations when fork is lost with warning (e.g. in Windows).
Is \f(CW\*(C`writeexit\*(C'\fR and so on files still created?
.SH "LICENSE"
.IX Header "LICENSE"
The \s-1MIT\s0 License. More info: <https://opensource.org/licenses/MIT>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Edgaras Sakuras \- edgaronas@yahoo.com <mailto:edgaronas@yahoo.com>
.PP
2018\-11\-29
